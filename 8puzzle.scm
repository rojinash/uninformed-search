;;
;; File
;;   8puzzle.scm
;;
;; Author
;;   Jerod Weinman
;;
;; Summary
;;   Provides procedures for generating 8-puzzle problems
;;
;; Provides
;;   (random-eight-puzzle-state moves)
;;   (eight-puzzle-problem)
;;   (eight-puzzle-state-board-list state)
;;   (eight-puzzle-misplaced state)

;(load "problem.scm")

;;
;; Procedure
;;   eight-puzzle-problem
;;
;; Purpose
;;   Create a problem representing the 8-puzzle
;;
;; Parameters
;;    [None.]
;;
;; Produces
;;   8-puzzle, a problem
;;
;; Preconditions
;;   [No additional.]
;;
;; Postconditions
;;   [No additional.]
(define eight-puzzle-problem
  (lambda ()
    (make-problem
     eight-puzzle-goal?
     (lambda (state) 
       (let ((actions (eight-puzzle-actions state)))
	 (map (lambda (action)
		(cons action (eight-puzzle-action-result state action)))
	      actions)))
     (lambda (state action) 1))))


;;
;; Procedure
;;   random-eight-puzzle-state
;;
;; Purpose
;;   Create a state randomly for the 8-puzzle
;;
;; Parameters
;;    moves, an integer
;;
;; Produces
;;   state, a state for the 8-puzzle problem
;;
;; Preconditions
;;   moves >= 0
;;
;; Postconditions
;;   state requires no more than moves actions to solve (but may require fewer)
;;
;; Practica
;;    state is generated by randomly applying moves actions to the goal state
;;
(define random-eight-puzzle-state
  (lambda (moves)
    (let loop ((moves moves)
	       (state eight-puzzle-goal-state))
      (if (zero? moves)
	  state
	  (let* ((actions (eight-puzzle-actions state))
		 (action (list-ref actions (random (length actions)))))
	    (loop (- moves 1)
		  (eight-puzzle-action-result state action)))))))


;;
;; Procedure
;;   eight-puzzle-state-board-list
;;
;; Purpose
;;   Get an interpretable list-representation of the 8-puzzle board
;;
;; Parameters
;;    state, a state for the 8-puzzle problem
;;
;; Produces
;;   board-list, a list
;;
;; Preconditions
;;   [No additional.]
;;
;; Postconditions
;;   (length board-list  3), and each list element  represents one row
;;   (in order) of the board. These elements in turn have length three
;;   and represent the value of the board at a column in that row.
;;   The blank is represented by the symbol x.
;;
(define eight-puzzle-state-board-list
  (lambda (state)
    (let* ((board (cadr state))
	   (bval (lambda (n) (slot-val board n))))
      (list (map bval '(1 2 3))
	    (map bval '(4 5 6))
	    (map bval '(7 8 9))))))

;;
;; Procedure
;;   eight-puzzle-misplaced
;;
;; Purpose
;;   Calculate the total number of misplaced tiles
;;
;; Parameters
;;    state, a state for the 8-puzzle problem
;;
;; Produces
;;   misplaced, a number
;;
;; Preconditions
;;   [No additional.]
;;
;; Postconditions
;;   misplaced is the number of elements that differ between (cdr state) and
;;  eight-puzzle-goal-board
(define eight-puzzle-misplaced
  (lambda (state)
    (apply + (map (lambda (tile goal-tile)
		    (if (equal? tile goal-tile) 0 1))
		  (cadr state) eight-puzzle-goal-board))))


;;
;; Procedure
;;   eight-puzzle-manhattan
;;
;; Purpose
;;   Calculate the Manhattan distance-based heuristic for the given board
;;
;; Parameters
;;    state, a state for the 8-puzzle problem
;;
;; Produces
;;   distance, a number
;;
;; Preconditions
;;   [No additional.]
;;
;; Postconditions
;;   distance is the sum of the distances (sum of vertical and
;;   horizontal distnace) of all the tiles from their goal positions

;; INCOMPLETE	     

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Support functions for 8-puzzle problem
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Get the list of actions available from each state
;; Depends only on where the blank tile is located
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define eight-puzzle-actions
  (lambda (state)
    (let ((blank-slot (car state)))
      (cond 
       ((= blank-slot 1)
	(list 'right 'down))
       ((= blank-slot 2)
	(list 'left 'right 'down))
       ((= blank-slot 3)
	(list 'left 'down))
       ((= blank-slot 4)
	(list 'right 'up 'down))
       ((= blank-slot 5)						
	(list 'left 'right 'up 'down))
       ((= blank-slot 6)						
	(list 'left 'up 'down))
       ((= blank-slot 7)						
	(list 'right 'up))
       ((= blank-slot 8)						
	(list 'left 'right 'up))
       ((= blank-slot 9)						
	(list 'left 'up))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; The standard goal board
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define eight-puzzle-goal-board
  (list 'x 1 2 3 4 5 6 7 8))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; State representation of the goal board (first element indicates
;; slot of blank tile
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define eight-puzzle-goal-state
  (list 1 eight-puzzle-goal-board))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Goal predicate
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define eight-puzzle-goal?
  (lambda (state)
    (if (or (not (list? state)) ; Detect basic misformating
	    (not (= 2 (length state)))
	    (not (and (number? (car state)) (positive? (car state))))
	    (not (list? (cadr state)))
	    (not (= 9 (length (cadr state)))))
	(error "Expected a valid 8-puzzle state; received " state)
	(equal? (cadr state)
		eight-puzzle-goal-board))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Transition function 
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define eight-puzzle-action-result
  (lambda (state action)
    (let* ((board (cadr state))
	   (blank-slot (car state))
	   (blank-loc (slot-loc blank-slot))
	   (other-slot (cond
			((eq? action 'left)
			 (loc-slot (col- blank-loc)))
			((eq? action 'right)
			 (loc-slot (col+ blank-loc)))
			((eq? action 'up)
			 (loc-slot (row- blank-loc)))
			((eq? action 'down)
			 (loc-slot (row+ blank-loc))))))
      (list other-slot
	    (swap-slots board blank-slot other-slot)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Location "accessors"
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define loc->row (lambda (loc) (car loc)))
(define loc->col (lambda (loc) (cadr loc)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Location changes
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define col+ (lambda (loc) (map + loc '(0 1))))
(define col- (lambda (loc) (map - loc '(0 1))))
(define row+ (lambda (loc) (map + loc '(1 0))))
(define row- (lambda (loc) (map - loc '(1 0))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; swap-slots
;;
;; Returns a board configuration where the values in two slots are transposed
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define swap-slots
  (lambda (board n m)
    (let ((first (min n m))
          (second (max n m)))
      (let loop ((subboard board)
                 (slot 1))
        (if (null? subboard)
            '()
            (cons 
             (if (= slot first)
                 (slot-val board second)
                 (if (= slot second)
                     (slot-val board first)
                     (car subboard)))
	     (loop (cdr subboard) (+ 1 slot))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Slot accessor function for a board
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define slot-val (lambda (b n) (list-ref b (- n 1))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Cartesian Location of a Slot
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define slot-loc (lambda (n)
                   (let* ((slot (if (zero? (modulo n 9)) 9 (remainder n 9)))
                          (row (if (<= slot 3)
				   1
				   (if (<= slot 6)
				       2
				       3)))
                          (col (if (zero? (modulo n 3)) 3 (remainder n 3))))
                     (list row col))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Slot of a Cartesian Location 
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define loc-slot (lambda (loc)
                   (let ((row (loc->row loc))
                         (col (loc->col loc)))
		     (+ col (* 3 (- row 1))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Slot of a tile
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define tile-slot
  (lambda (board tile)
    (let loop ((slot 1)
	       (remaining board))
      (cond 
       ((null? remaining)
	0) ;; Not found. This is an error case
       ((= (car remaining) tile)
	slot)
       (else
	(loop (+ 1 slot) (cdr remaining)))))))
	  